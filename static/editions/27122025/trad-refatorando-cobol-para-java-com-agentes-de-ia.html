<article>
    <a href="/editions/27122025/index.html">Voltar</a>
    <h2> [trad] Refatorando COBOL para Java com Agentes de IA</h2>
    <div class="meta">
        <span class="author">paulogpd</span>
        <span class="date">19.12.2025 15:23</span>

    </div>
    <p>A modernização de sistemas em <a href="https://en.wikipedia.org/wiki/COBOL">COBOL</a> é um dos desafios mais urgentes enfrentados por empresas atualmente. O Gartner estimou que existem mais de 200 bilhões de linhas de código COBOL em operação, executando 80% dos sistemas empresariais do mundo. Em 2020, o COBOL ainda era responsável por 95% dos processos de transação com cartões de crédito e débito.</p>
<p>O desafio é crítico: <a href="https://softwaremodernizationservices.com/mainframe-modernization">47% das organizações</a> atualmente têm dificuldade em preencher cargos que exigem COBOL, com salários crescendo 25% ao ano. Até 2027, 92% dos desenvolvedores restantes de COBOL terão se aposentado. As abordagens tradicionais de modernização têm apresentado <a href="https://www.linkedin.com/posts/jeanlucs_cobol-mainframe-as400-activity-7397385359770423296-VOLP">altas taxas de falha</a>, já que a sintaxe única do COBOL dificulta o trabalho de equipes humanas. Agora, a IA está alcançando o que exércitos de desenvolvedores não conseguiram: análise, transformação e verificação automatizadas de código em escala.</p>
<h2>Uma abordagem de refinamento iterativo</h2>
<p>Converter simplesmente a sintaxe de COBOL para Java não é suficiente — o código convertido precisa preservar a lógica de negócio, seguir as convenções do Java e ser mantido por equipes de desenvolvimento modernas.</p>
<p>Na <a href="https://openhands.dev/">OpenHands</a>, uma das abordagens mais eficazes que encontramos é o padrão de refinamento iterativo usando múltiplos agentes em um ciclo de feedback:</p>
<ol>
<li>Um <strong>agente de refatoração</strong> converte arquivos COBOL em Java</li>
<li>Um <strong>agente de crítica</strong> avalia a qualidade de cada conversão e atribui uma pontuação</li>
<li>Se a pontuação estiver abaixo do limite de qualidade, o processo se repete com base no feedback da crítica</li>
</ol>
<p>O resultado é mais do que apenas código executável: é código que reproduz fielmente o original e atende aos padrões de qualidade e manutenibilidade exigidos.</p>
<h2>Como funciona</h2>
<p>A ideia é simples: um agente realiza o trabalho, outro verifica o resultado e, se não estiver bom o suficiente, o primeiro tenta novamente com base no feedback. Veja como isso se parece em código usando o <a href="https://github.com/OpenHands/software-agent-sdk">OpenHands SDK</a>:</p>
<pre><code class="language-markdown">While current_score &lt; QUALITY_THRESHOLD and iteration &lt; MAX_ITERATIONS:  
# Agente de refatoração converte COBOL para Java  
refactoring_conversation.send_message(refactoring_prompt)  
refactoring_conversation.run()  
    
# Agente de crítica avalia a conversão  
critique_conversation.send_message(critique_prompt)  
critique_conversation.run()  
    
# Analisa a pontuação e decide se deve continuar  
current_score = parse_critique_score(critique_file)
</code></pre>
<p>O agente de refatoração recebe instruções sobre os requisitos da conversão: preservar a lógica de negócio, usar convenções de nomenclatura Java, implementar tratamento de erros e adicionar documentação.</p>
<p>O agente de crítica avalia cada arquivo convertido quanto à correção, qualidade do código, completude e boas práticas — gerando um relatório estruturado com problemas específicos a serem corrigidos. Se o código não atingir o padrão especificado, o agente de refatoração executa novamente com base no feedback, aplicando melhorias direcionadas.</p>
<h2>Exemplo</h2>
<p>Aqui está um programa COBOL de gerenciamento de clientes:</p>
<pre><code class="language-cobol">1000 - MAIN-PROCESS.  
DISPLAY &quot;CUSTOMER MANAGEMENT SYSTEM&quot;  
EVALUATE TRUE  
    WHEN OP-ADD  
        PERFORM 2000-ADD-CUSTOMER  
    WHEN OP-UPDATE  
        PERFORM 3000-UPDATE-CUSTOMER  
    WHEN OP-DELETE  
        PERFORM 4000-DELETE-CUSTOMER  
END - EVALUATE.  
</code></pre>
<p>O agente converte isso em Java idiomático:</p>
<pre><code class="language-java">public class CustomerManagement {  
    public void mainProcess() {  
        System.out.println(&quot;CUSTOMER MANAGEMENT SYSTEM&quot;);  
        switch (operation) {  
            case ADD -&gt; addCustomer();  
            case UPDATE -&gt; updateCustomer();  
            case DELETE -&gt; deleteCustomer();  
            default -&gt; System.out.println(&quot;INVALID OPERATION&quot;);  
        }  
    }  
}  
</code></pre>
<h2>Experimente</h2>
<p>O exemplo completo de refinamento iterativo está disponível no OpenHands SDK. Assim que os PRs pendentes forem mesclados, você poderá encontrá-lo em:</p>
<ul>
<li><strong>Código</strong>: <a href="https://github.com/OpenHands/software-agent-sdk/blob/main/examples/01_standalone_sdk/31_iterative_refinement.py">examples/01_standalone_sdk/31_iterative_refinement.py</a></li>
<li><strong>Documentação</strong>: <a href="https://docs.openhands.dev/sdk/guides/iterative-refinement">Iterative Refinement Guide</a></li>
</ul>
<p>Para executar o exemplo:</p>
<pre><code>export LLM_API_KEY=&quot;sua-api-key&quot;  
cd software-agent-sdk  
uv run python examples/01_standalone_sdk/31_iterative_refinement.py  
</code></pre>
<p>Para arquivos COBOL reais, você pode usar a <a href="https://github.com/aws-samples/aws-mainframe-modernization-carddemo/tree/main/app/cbl">aplicação AWS CardDemo</a>, que fornece um aplicativo de mainframe representativo para testar abordagens de modernização.</p>
<h2>Escalando a aplicação com o Large Codebase SDK</h2>
<p>O exemplo de refinamento iterativo funciona bem para bases de código pequenas e médias. Mas sistemas corporativos COBOL podem ter milhões de linhas em milhares de programas, com interdependências complexas.</p>
<p>Para esses projetos de modernização em larga escala, desenvolvemos o <strong>OpenHands Large Codebase SDK</strong>. Esse kit estende o padrão de refinamento iterativo com:</p>
<ul>
<li><strong>Ferramentas de análise de dependências</strong> que identificam componentes independentes e a ordem ótima de migração</li>
<li><strong>Orquestração paralela de agentes</strong> para processar múltiplos arquivos simultaneamente</li>
<li><strong>Dashboards de acompanhamento de progresso</strong> para monitorar o status geral da modernização</li>
<li><strong>Verificação de equivalência semântica</strong> para garantir que o novo aplicativo Java se comporte exatamente como o sistema COBOL legado</li>
</ul>
<p>O Large Codebase SDK também inclui fluxos de trabalho especializados de refatoração de COBOL que compreendem padrões comuns de mainframe — transações CICS, jobs JCL, manipulação de arquivos VSAM — e os convertem em equivalentes apropriados em Java.</p>
<h2>Saiba mais</h2>
<ul>
<li><a href="https://openhands.dev/contact">Entre em contato com nossa equipe</a> para discutir seu caso de uso.</li>
<li><a href="https://dub.sh/openhands">Junte-se à nossa comunidade no Slack</a> para trocar experiências com outros profissionais enfrentando desafios semelhantes.</li>
</ul>
<p>Tradução pirata do artigo da OpenHands sobre <a href="https://openhands.dev/blog/20251218-cobol-to-java-refactoring?utm_source=newsletter&amp;utm_medium=email&amp;utm_campaign=newsletter-19dec25">Refactoring COBOL to Java with AI Agents</a></p>
<hr />
<h2>Citação do artigo original</h2>
<pre><code>OpenHands. 2025. 
“Refactoring COBOL to Java with AI Agents.” 
OpenHands Blog, December 18, 2025. 
https://openhands.dev/blog/20251218-cobol-to-java-refactoring
</code></pre>
</article>